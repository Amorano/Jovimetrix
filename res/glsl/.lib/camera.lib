//------------------------------------------------------------------------------
// CAMERA
//------------------------------------------------------------------------------

#import .lib/const.lib

// =============================================================================
// PROTOTYPES
// =============================================================================

vec3 lib_camera_eye(float fov, vec2 size, vec2 pos);    // Camera direction based on field of view and screen position
mat3 lib_camera_eye(vec3 pos, vec3 target, float roll); // Camera view based on eye, target, and roll angle

//------------------------------------------------------------------------------
// TRANSFORM
//------------------------------------------------------------------------------

// Camera direction based on field of view and screen position
vec3 lib_camera_eye(float fov, vec2 size, vec2 pos) {
    vec2 xy = pos - size * 0.5;
    float cot_half_fov = tan((90.0 - fov * 0.5) * M_DEG2RAD);
    float z = size.y * 0.5 * cot_half_fov;
    return normalize(vec3(xy, -z));
}

// Camera view based on eye, target, and roll angle
mat3 lib_camera_eye(vec3 pos, vec3 target, float roll)
{
    vec3 cw = normalize(target-pos);
    vec3 cp = vec3(sin(roll), cos(roll),0.0);
    vec3 cu = normalize( cross(cw,cp) );
    vec3 cv = normalize( cross(cu,cw) );
    return mat3(cu, cv, cw);
}

//------------------------------------------------------------------------------
// SHADING
//------------------------------------------------------------------------------

// Computes the Fresnel reflection factor
vec3 lib_shading_fresnel(vec3 F0, vec3 h, vec3 l) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - dot(h, l), 0.0, 1.0), 5.0);
}

vec3 lib_shading_phong_light(vec3 pos, vec3 color) {
    vec3 vl = normalize(light_pos - v);
    vec3 diffuse = Kd * vec3(max(0.0, dot(vl, n)));
    vec3 specular = vec3(max(0.0, dot(vl, ref)));
    vec3 F = lib_shading_fresnel(Ks, normalize(vl - dir), vl);
    specular = pow(specular, vec3(shininess));
    return light_color * mix(diffuse, specular, F);
}

// Computes Phong shading for a given point
vec3 lib_shading_phong(vec3 v, vec3 n, vec3 dir, vec3 eye) {
    // Define material properties
    float shininess = 16.0;
    vec3 final = vec3(0.0);
    vec3 ref = reflect(dir, n);
    vec3 Ks = vec3(0.5);
    vec3 Kd = vec3(1.0);

    // Light 0
    {
        vec3 light_pos = vec3(20.0, 20.0, 20.0);
        vec3 light_color = vec3(1.0, 0.7, 0.7);
        final += lib_shading_phong_light(light_pos, light_color);
    }

    // Light 1
    {
        vec3 light_pos = vec3(-20.0, -20.0, -30.0);
        vec3 light_color = vec3(0.5, 0.7, 1.0);
        final += lib_shading_phong_light(light_pos, light_color);
    }
    return final;
}