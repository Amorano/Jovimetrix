//------------------------------------------------------------------------------
// INTERPOLATION
//------------------------------------------------------------------------------

#include .lib/const.lib

// =============================================================================
// PROTOTYPES
// =============================================================================

float lib_decayExp(float t, float lambda);
float lib_interpSS(float a, float b, float t);
vec3 lib_interpSS(vec3 a, vec3 b, float t);
float lib_interpHermite(float t);
vec3 lib_interpHermite(vec3 a, vec3 b, vec3 tangentA, vec3 tangentB, float t);
float lib_easeInOutSine(float t);
vec3 lib_easeInOutSine(vec3 a, vec3 b, float t);
float lib_interpBounce(float t);
vec3 lib_interpBounce2Points(vec3 a, vec3 b, float t);
float lib_easeInOutCirc(float t);
vec3 lib_easeInOutCirc(vec3 a, vec3 b, float t);
float lib_easeInOutQuad(float t);
vec3 lib_easeInOutQuad(vec3 a, vec3 b, float t);

//------------------------------------------------------------------------------
// EXPONENTIAL DECAY (Falloff)
//------------------------------------------------------------------------------
// Compute exponential decay for smooth falloff over time
float lib_decayExp(float t, float lambda) {
    return exp(-lambda * t);
}

//------------------------------------------------------------------------------
// SMOOTHSTEP INTERPOLATION
//------------------------------------------------------------------------------
// Smooth interpolation between 0 and 1 with cubic Hermite smoothing
float lib_interpSS(float a, float b, float t) {
    return mix(a, b, smoothstep(0.0, 1.0, t));
}

vec3 lib_interpSS(vec3 a, vec3 b, float t) {
    return mix(a, b, smoothstep(0.0, 1.0, t));
}

//------------------------------------------------------------------------------
// HERMITE INTERPOLATION (Cubic Spline)
//------------------------------------------------------------------------------
// Smooth curve interpolation between two points using cubic Hermite spline
float lib_interpHermite(float t) {
    return t * t * (3.0 - 2.0 * t);
}

// Hermite interpolation with tangents for smoother control over curves
vec3 lib_interpHermite(vec3 a, vec3 b, vec3 tangentA, vec3 tangentB, float t) {
    float h00 = 2.0 * t * t * t - 3.0 * t * t + 1.0;
    float h10 = t * t * t - 2.0 * t * t + t;
    float h01 = -2.0 * t * t * t + 3.0 * t * t;
    float h11 = t * t * t - t * t;
    return h00 * a + h10 * tangentA + h01 * b + h11 * tangentB;
}

//------------------------------------------------------------------------------
// EASE IN-OUT (SINE)
//------------------------------------------------------------------------------
// Ease-in and ease-out interpolation using sine curve
float lib_easeInOutSine(float t) {
    return -0.5 * (cos(M_PI * t) - 1.0);
}

vec3 lib_easeInOutSine(vec3 a, vec3 b, float t) {
    return mix(a, b, lib_easeInOutSine(t));
}

//------------------------------------------------------------------------------
// BOUNCE INTERPOLATION
//------------------------------------------------------------------------------
// Creates a bouncing effect using a sine function for smooth oscillation
float lib_interpBounce(float t) {
    return abs(sin(M_TAU * t * (1.0 - t)));
}

// Apply bounce effect between two points
vec3 lib_interpBounce2Points(vec3 a, vec3 b, float t) {
    return mix(a, b, lib_interpBounce(t));
}

//------------------------------------------------------------------------------
// CIRCULAR INTERPOLATION
//------------------------------------------------------------------------------
// Circular ease-in and ease-out interpolation
float lib_easeInOutCirc(float t) {
    t *= 2.0;
    if (t < 1.0) return -0.5 * (sqrt(1.0 - t * t) - 1.0);
    t -= 2.0;
    return 0.5 * (sqrt(1.0 - t * t) + 1.0);
}

vec3 lib_easeInOutCirc(vec3 a, vec3 b, float t) {
    return mix(a, b, lib_easeInOutCirc(t));
}

//------------------------------------------------------------------------------
// EASE IN-OUT (QUADRATIC)
//------------------------------------------------------------------------------
// Quadratic ease-in and ease-out interpolation
float lib_easeInOutQuad(float t) {
    t *= 2.0;
    if (t < 1.0) return 0.5 * t * t;
    t -= 1.0;
    return -0.5 * (t * (t - 2.0) - 1.0);
}

vec3 lib_easeInOutQuad(vec3 a, vec3 b, float t) {
    return mix(a, b, lib_easeInOutQuad(t));
}
