//------------------------------------------------------------------------------
// NOISE
//------------------------------------------------------------------------------

// =============================================================================
// PROTOTYPES
// =============================================================================

float lib_noise_dithered(vec2 p);
float lib_noise_rand(vec2 co);
float lib_noise_rand(vec3 co);
float lib_noise_rand(vec4 co);
float lib_noise_gradient_2d(vec2 p);
float lib_noise_gradient_3d(vec3 p);
float lib_noise_gradient_4d(vec4 p);
float lib_noise_simplex_2d(vec2 v);
float lib_noise_perlin(vec2 p);
float lib_noise_worley_2d(vec2 p, int num_cells);
float lib_noise_worley_3d(vec3 p, int num_cells);
vec2 lib_noise_gradient_2d(int hash, vec2 p);
vec3 lib_noise_gradient_3d(int hash, vec3 p);
vec4 lib_noise_gradient_4d(int hash, vec4 p);
float lib_noise_fractal_2d(vec2 p, float octaves, float persistence);
float lib_noise_fractal_3d(vec3 p, float octaves, float persistence);
float lib_noise_fractal_4d(vec4 p, float octaves, float persistence);
float lib_noise_turbulence_2d(vec2 p, float size);
float lib_noise_turbulence_3d(vec3 p, float size);
float lib_noise_value_2d(vec2 p);
float lib_noise_value_3d(vec3 p);

//------------------------------------------------------------------------------
// DITHERED NOISE
//------------------------------------------------------------------------------
// Dithered noise
float lib_noise_dithered(vec2 p) {
    float base  = lib_noise_perlin(p);
    float dither = fract(sin(dot(floor(p), vec2(12.9898, 78.233))) * 43758.5453123);
    return base + dither * 0.5;
}

//------------------------------------------------------------------------------
// RANDOM VALUE
//------------------------------------------------------------------------------
// Generate a pseudo-random value based on a 2D coordinate
float lib_noise_rand(vec2 co) {
    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453123);
}

// Generate a pseudo-random value based on a 3D coordinate
float lib_noise_rand(vec3 co) {
    return fract(sin(dot(co, vec3(12.9898, 78.233, 45.678))) * 43758.5453123);
}

// Generate a pseudo-random value based on a 4D coordinate
float lib_noise_rand(vec4 co) {
    return fract(sin(dot(co, vec4(12.9898, 78.233, 45.678, 94.673))) * 43758.5453123);
}

//------------------------------------------------------------------------------
// GRADIENT NOISE
//------------------------------------------------------------------------------
// Generate a 2D gradient noise value
float lib_noise_gradient_2d(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    // Compute random values at the corners of the square
    float a = lib_noise_rand(i);
    float b = lib_noise_rand(i + vec2(1.0, 0.0));
    float c = lib_noise_rand(i + vec2(0.0, 1.0));
    float d = lib_noise_rand(i + vec2(1.0, 1.0));

    // Compute fade curves for interpolation
    vec2 u = f * f * (3.0 - 2.0 * f);

    // Interpolate between the points
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Generate a 3D gradient noise value
float lib_noise_gradient_3d(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);

    // Compute random values at the corners of the cube
    float a  = lib_noise_rand(i);
    float b  = lib_noise_rand(i + vec3(1.0, 0.0, 0.0));
    float c  = lib_noise_rand(i + vec3(0.0, 1.0, 0.0));
    float d  = lib_noise_rand(i + vec3(1.0, 1.0, 0.0));
    float e  = lib_noise_rand(i + vec3(0.0, 0.0, 1.0));
    float f0 = lib_noise_rand(i + vec3(1.0, 0.0, 1.0));
    float g0 = lib_noise_rand(i + vec3(0.0, 1.0, 1.0));
    float h0 = lib_noise_rand(i + vec3(1.0, 1.0, 1.0));

    // Compute fade curves for interpolation
    vec3 u = f * f * (3.0 - 2.0 * f);

    // Interpolate between the points
    float v0 = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
    float v1 = mix(mix(e, f0, u.x), mix(g0, h0, u.x), u.y);

    return mix(v0, v1, u.z);
}

// Generate a 4D gradient noise value
float lib_noise_gradient_4d(vec4 p) {
    vec4 i = floor(p);
    vec4 f = fract(p);

    // Compute random values at the corners of the hypercube
    float a  = lib_noise_rand(i);
    float b  = lib_noise_rand(i + vec4(1.0, 0.0, 0.0, 0.0));
    float c  = lib_noise_rand(i + vec4(0.0, 1.0, 0.0, 0.0));
    float d  = lib_noise_rand(i + vec4(1.0, 1.0, 0.0, 0.0));
    float e  = lib_noise_rand(i + vec4(0.0, 0.0, 1.0, 0.0));
    float f0 = lib_noise_rand(i + vec4(1.0, 0.0, 1.0, 0.0));
    float g0 = lib_noise_rand(i + vec4(0.0, 1.0, 1.0, 0.0));
    float h0 = lib_noise_rand(i + vec4(1.0, 1.0, 1.0, 0.0));
    float i1 = lib_noise_rand(i + vec4(0.0, 0.0, 0.0, 1.0));
    float j1 = lib_noise_rand(i + vec4(1.0, 0.0, 0.0, 1.0));
    float k1 = lib_noise_rand(i + vec4(0.0, 1.0, 0.0, 1.0));
    float l1 = lib_noise_rand(i + vec4(1.0, 1.0, 0.0, 1.0));
    float m1 = lib_noise_rand(i + vec4(0.0, 0.0, 1.0, 1.0));
    float n1 = lib_noise_rand(i + vec4(1.0, 0.0, 1.0, 1.0));
    float o1 = lib_noise_rand(i + vec4(0.0, 1.0, 1.0, 1.0));
    float p1 = lib_noise_rand(i + vec4(1.0, 1.0, 1.0, 1.0));

    // Compute fade curves for interpolation
    vec4 u = f * f * (3.0 - 2.0 * f);

    // Interpolate between the points
    float v0 = mix(mix(mix(a, b, u.x), mix(c, d, u.x), u.y), mix(mix(e, f0, u.x), mix(g0, h0, u.x), u.y), u.z);
    float v1 = mix(mix(mix(i1, j1, u.x), mix(k1, l1, u.x), u.y), mix(mix(m1, n1, u.x), mix(o1, p1, u.x), u.y), u.w);

    return mix(v0, v1, u.w);
}

//------------------------------------------------------------------------------
// GRADIENT NOISE
//------------------------------------------------------------------------------
// 2D Simplex noise function (simplified)
float lib_noise_simplex_2d(vec2 v) {
    const vec2 C = vec2(0.211324865405187, 0.366025403784439); // (3 - sqrt(3)) / 6
    vec2  i  = floor(v + (v.x + v.y) * C);
    vec2  x0 = v - i + (i.x + i.y) * C;
    vec2  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    vec2  x1 = x0 - i1 + C;
    vec2  x2 = x0 - 1.0 + 2.0 * C;
    vec3  p  = vec3(x0, 0.0);
    vec3  p1 = vec3(x1, 0.0);
    vec3  p2 = vec3(x2, 0.0);

    // Dot product and fade curve functions
    float t0 = 0.5 - dot(p, p);
    float t1 = 0.5 - dot(p1, p1);
    float t2 = 0.5 - dot(p2, p2);

    // Fade curve function
    vec3 g0 = lib_noise_gradient_2d(int(i.x + i.y) & 3, p);
    vec3 g1 = lib_noise_gradient_2d(int(i.x + i.y + 1) & 3, p1);
    vec3 g2 = lib_noise_gradient_2d(int(i.x + i.y + 2) & 3, p2);

    t0 = t0 < 0.0 ? 0.0 : t0 * t0 * t0 * t0 * dot(g0, p);
    t1 = t1 < 0.0 ? 0.0 : t1 * t1 * t1 * t1 * dot(g1, p1);
    t2 = t2 < 0.0 ? 0.0 : t2 * t2 * t2 * t2 * dot(g2, p2);
    return 70.0 * (t0 + t1 + t2);
}

//------------------------------------------------------------------------------
// GRADIENT NOISE
//------------------------------------------------------------------------------
// Generate 2D Perlin noise
float lib_noise_perlin(vec2 p) {
    vec2  i = floor(p);
    vec2  f = fract(p);
    float a = lib_noise_rand(i);
    float b = lib_noise_rand(i + vec2(1.0, 0.0));
    float c = lib_noise_rand(i + vec2(0.0, 1.0));
    float d = lib_noise_rand(i + vec2(1.0, 1.0));
    vec2  u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

//------------------------------------------------------------------------------
// GRADIENT NOISE
//------------------------------------------------------------------------------
// 2D Worley noise function (Cellular noise)
float lib_noise_worley_2d(vec2 p, int num_cells) {
    vec2  i = floor(p);
    vec2  f = fract(p);
    float d = 1.0; // Initial distance (for min distance to feature points)

    for (int x = -num_cells; x <= num_cells; ++x) {
        for (int y = -num_cells; y <= num_cells; ++y) {
            vec2  cell   = vec2(float(x), float(y));
            vec2  point  = cell + vec2(lib_noise_rand(i + cell), lib_noise_rand(i + cell + vec2(42.0, 17.0)));
            vec2  offset = point - f;
            float len    = length(offset);
            d = min(d, len);
        }
    }
    return d;
}

// 3D Worley noise function (Cellular noise)
float lib_noise_worley_3d(vec3 p, int num_cells) {
    vec3  i = floor(p);
    vec3  f = fract(p);
    float d = 1.0; // Initial distance (for min distance to feature points)

    for (int x = -num_cells; x <= num_cells; ++x) {
        for (int y = -num_cells; y <= num_cells; ++y) {
            for (int z = -num_cells; z <= num_cells; ++z) {
                vec3  cell   = vec3(float(x), float(y), float(z));
                vec3  point  = cell + vec3(lib_noise_rand(i + cell),
                                           lib_noise_rand(i + cell + vec3(42.0, 17.0, 23.0)),
                                           lib_noise_rand(i + cell + vec3(23.0, 31.0, 51.0)));
                vec3  offset = point - f;
                float len    = length(offset);
                d = min(d, len);
            }
        }
    }
    return d;
}

//------------------------------------------------------------------------------
// GRADIENT SMOOTHING
//------------------------------------------------------------------------------
// Gradient function for 2D
vec2 lib_noise_gradient_2d(int hash, vec2 p) {
    const vec2 grad[4] = vec2[](
        vec2( 1.0,  1.0),
        vec2(-1.0,  1.0),
        vec2( 1.0, -1.0),
        vec2(-1.0, -1.0)
    );
    return grad[hash & 3];
}

// Gradient function for 3D
vec3 lib_noise_gradient_3d(int hash, vec3 p) {
    const vec3 grad[12] = vec3[](
        vec3( 1.0,  1.0,  0.0),
        vec3(-1.0,  1.0,  0.0),
        vec3( 1.0, -1.0,  0.0),
        vec3(-1.0, -1.0,  0.0),
        vec3( 1.0,  0.0,  1.0),
        vec3(-1.0,  0.0,  1.0),
        vec3( 1.0,  0.0, -1.0),
        vec3(-1.0,  0.0, -1.0),
        vec3( 0.0,  1.0,  1.0),
        vec3( 0.0, -1.0,  1.0),
        vec3( 0.0,  1.0, -1.0),
        vec3( 0.0, -1.0, -1.0)
    );
    return grad[hash % 12];
}

vec4 lib_noise_gradient_4d(int hash, vec4 p) {
    const vec4 grad[32] = vec4[](
        vec4( 1.0,  1.0,  1.0,  0.0),
        vec4(-1.0,  1.0,  1.0,  0.0),
        vec4( 1.0, -1.0,  1.0,  0.0),
        vec4(-1.0, -1.0,  1.0,  0.0),
        vec4( 1.0,  1.0, -1.0,  0.0),
        vec4(-1.0,  1.0, -1.0,  0.0),
        vec4( 1.0, -1.0, -1.0,  0.0),
        vec4(-1.0, -1.0, -1.0,  0.0),
        vec4( 1.0,  1.0,  0.0,  1.0),
        vec4(-1.0,  1.0,  0.0,  1.0),
        vec4( 1.0, -1.0,  0.0,  1.0),
        vec4(-1.0, -1.0,  0.0,  1.0),
        vec4( 1.0,  0.0,  1.0,  1.0),
        vec4(-1.0,  0.0,  1.0,  1.0),
        vec4( 1.0,  0.0, -1.0,  1.0),
        vec4(-1.0,  0.0, -1.0,  1.0),
        vec4( 0.0,  1.0,  1.0,  1.0),
        vec4( 0.0, -1.0,  1.0,  1.0),
        vec4( 0.0,  1.0, -1.0,  1.0),
        vec4( 0.0, -1.0, -1.0,  1.0),
        vec4( 1.0,  1.0,  0.0, -1.0),
        vec4(-1.0,  1.0,  0.0, -1.0),
        vec4( 1.0, -1.0,  0.0, -1.0),
        vec4(-1.0, -1.0,  0.0, -1.0),
        vec4( 1.0,  0.0,  1.0, -1.0),
        vec4(-1.0,  0.0,  1.0, -1.0),
        vec4( 1.0,  0.0, -1.0, -1.0),
        vec4(-1.0,  0.0, -1.0, -1.0),
        vec4( 0.0,  1.0,  1.0, -1.0),
        vec4( 0.0, -1.0,  1.0, -1.0),
        vec4( 0.0,  1.0, -1.0, -1.0),
        vec4( 0.0, -1.0, -1.0, -1.0)
    );
    return grad[hash & 31];
}

//------------------------------------------------------------------------------
// FRACTAL NOISE
//------------------------------------------------------------------------------
// 2D Fractal noise function with Perlin noise
float lib_noise_fractal_2d(vec2 p, float octaves, float persistence) {
    float total     = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float max_value = 0.0;

    for (float i = 0.0; i < octaves; i++) {
        total     += lib_noise_gradient_2d(p * frequency) * amplitude;
        max_value += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }

    return total / max_value;
}

// 3D Fractal noise function with Perlin noise
float lib_noise_fractal_3d(vec3 p, float octaves, float persistence) {
    float total     = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float max_value = 0.0;

    for (float i = 0.0; i < octaves; i++) {
        total     += lib_noise_gradient_3d(p * frequency) * amplitude;
        max_value += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }

    return total / max_value;
}

// 4D Fractal noise function with Perlin noise
float lib_noise_fractal_4d(vec4 p, float octaves, float persistence) {
    float total     = 0.0;
    float frequency = 1.0;
    float amplitude = 1.0;
    float max_value = 0.0;

    for (float i = 0.0; i < octaves; i++) {
        total     += lib_noise_gradient_4d(p * frequency) * amplitude;
        max_value += amplitude;
        amplitude *= persistence;
        frequency *= 2.0;
    }
    return total / max_value;
}

//------------------------------------------------------------------------------
// TURBULENCE NOISE
//------------------------------------------------------------------------------
// Turbulence function using 2D Perlin noise
float lib_noise_turbulence_2d(vec2 p, float size) {
    float value = 0.0;
    float initial_size = size;

    while (size >= 1.0) {
        value += lib_noise_perlin(p / size) * size;
        size /= 2.0;
    }

    return 0.5 * value / initial_size;
}

// Turbulence function using 3D Perlin noise
float lib_noise_turbulence_3d(vec3 p, float size) {
    float value = 0.0;
    float initial_size = size;

    while (size >= 1.0) {
        value += lib_noise_gradient_3d(p / size) * size;
        size /= 2.0;
    }

    return 0.5 * value / initial_size;
}

//------------------------------------------------------------------------------
// VALUE NOISE
//------------------------------------------------------------------------------
// Value noise function for 2D
float lib_noise_value_2d(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = lib_noise_rand(i);
    float b = lib_noise_rand(i + vec2(1.0, 0.0));
    float c = lib_noise_rand(i + vec2(0.0, 1.0));
    float d = lib_noise_rand(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Value noise function for 3D
float lib_noise_value_3d(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);

    float a = lib_noise_rand(i);
    float b = lib_noise_rand(i + vec3(1.0, 0.0, 0.0));
    float c = lib_noise_rand(i + vec3(0.0, 1.0, 0.0));
    float d = lib_noise_rand(i + vec3(1.0, 1.0, 0.0));
    float e = lib_noise_rand(i + vec3(0.0, 0.0, 1.0));
    float f1 = lib_noise_rand(i + vec3(1.0, 0.0, 1.0));
    float g = lib_noise_rand(i + vec3(0.0, 1.0, 1.0));
    float h = lib_noise_rand(i + vec3(1.0, 1.0, 1.0));

    vec3 u = f * f * (3.0 - 2.0 * f);
    return mix(
        mix(mix(a, b, u.x), mix(c, d, u.x), u.y),
        mix(mix(e, f1, u.x), mix(g, h, u.x), u.y),
        u.z
    );
}

//------------------------------------------------------------------------------
// VORONOI NOISE
//------------------------------------------------------------------------------
// Voronoi noise function for 2D
vec2 lib_noise_voronoi_2d(vec2 p) {
    vec2 n = floor(p);
    vec2 f = fract(p);

    vec2 m = vec2(8.0);
    for (int j = -1; j <= 1; j++) {
        for (int i = -1; i <= 1; i++) {
            vec2 g = vec2(float(i), float(j));
            vec2 o = lib_noise_rand(n + g);
            vec2 r = g + o - f;
            float d = dot(r, r);
            if (d < m.x) {
                m.y = m.x;
                m.x = d;
            } else if (d < m.y) {
                m.y = d;
            }
        }
    }
    return sqrt(m);
}

// Voronoi noise function for 3D
vec2 lib_noise_voronoi_3d(vec3 p) {
    vec3 n = floor(p);
    vec3 f = fract(p);

    vec2 m = vec2(8.0);
    for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
            for (int i = -1; i <= 1; i++) {
                vec3 g = vec3(float(i), float(j), float(k));
                vec3 o = vec3(lib_noise_rand(n + g), lib_noise_rand(n + g + vec3(13.5, 7.3, 2.8)), lib_noise_rand(n + g + vec3(3.7, 5.1, 11.9)));
                vec3 r = g + o - f;
                float d = dot(r, r);
                if (d < m.x) {
                    m.y = m.x;
                    m.x = d;
                } else if (d < m.y) {
                    m.y = d;
                }
            }
        }
    }
    return sqrt(m);
}
