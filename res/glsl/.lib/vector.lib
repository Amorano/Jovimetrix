//------------------------------------------------------------------------------
// VECTOR
//------------------------------------------------------------------------------

// =============================================================================
// DEFINE
// =============================================================================

#define VEC_PROJECT(a, b) ((dot(a, b) / dot(b, b)) * b) // Project one vector onto another
#define VEC_ORTHOGONAL2(v) vec2(-(v).y, (v).x)      // Orthogonal
#define VEC_ORTHOGONAL3(v) \
    (abs((v).x) > abs((v).y) ? normalize(vec3(-(v).z, 0.0, (v).x)) : \
                               normalize(vec3(0.0, (v).z, -(v).y)))
#define VEC_ANGLEBETWEEN(a, b) acos(clamp(dot(normalize(a), normalize(b)), -1.0, 1.0))

// =============================================================================
// PROTOTYPE
// =============================================================================

float lib_vec_ndot(in vec2 a, in vec2 b);  // 2D vector "negative dot product"
mat3 lib_vec_rotationXY(vec2 angle);       // Rotation matrix for 2D rotation
vec2 lib_vec_rotate2(vec2 v, float angle); // 2D vector rotation by angle

//------------------------------------------------------------------------------
// ANGLE
//------------------------------------------------------------------------------

// Compute the "negative dot product" of two 2D vectors
float lib_vec_ndot(in vec2 a, in vec2 b) {
    return a.x*b.x - a.y*b.y;
}

// Creates a rotation matrix for pitch, yaw
mat3 lib_vec_rotationXY( vec2 angle ) {
	vec2 c = cos( angle );
	vec2 s = sin( angle );

	return mat3(
		c.y      ,  0.0, -s.y,
		s.y * s.x,  c.x,  c.y * s.x,
		s.y * c.x, -s.x,  c.y * c.x
	);
}

// Rotates a 2D vector by angle in radians
vec2 lib_vec_rotate2(vec2 v, float angle) {
    float cosA = cos(angle);
    float sinA = sin(angle);
    return vec2(
        v.x * cosA - v.y * sinA,
        v.x * sinA + v.y * cosA
    );
}
